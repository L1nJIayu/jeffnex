# 数据劫持

Vue2的依赖追踪，主要通过定义`Dep`类，配合`getter`和`setter`实现依赖的绑定和通知，可以理解成发布订阅的模式。



我们先来实现一个`watchEffect`，先不涉及`getter`和`setter`

```js
const state = {
  count: 0
}

watchEffect(() => {
  console.log(`state.count update: ${state.count}`)
})

let activeFn = null
function watchEffect(fn) {
  function wrapFn() {
    activeFn = fn
    fn()
    activeFn = null
  }
  wrapFn()
}
```

要让`watchEffect`能够生效，需要定义一个`Dep`类

```js
class Dep {
  constructor() {
    this.subscribers = new Set()
  }
  // 将回调函数保存起来
  depend() {
    if(activeFn) {
      this.subscribers.add(activeFn)
    }
  }
  // 将保存起来的回调函数依次执行
  notify() {
    this.subscribers.forEach(sub => sub())
  }
}
```

修改`watchEffect`传递的回调函数，在调用的时候，把回调函数保存到依赖中

```js{23}
class Dep {
  constructor() {
    this.subscribers = new Set()
  }
  // 将回调函数保存起来
  depend() {
    if(activeFn) {
      this.subscribers.add(activeFn)
    }
  }
  // 将保存起来的回调函数依次执行
  notify() {
    this.subscribers.forEach(sub => sub())
  }
}

const state = {
  count: 0
}
const dep = new Dep()

watchEffect(() => {
  dep.depend()
  console.log(`state.count update: ${state.count}`)
})

let activeFn = null
function watchEffect(fn) {
  function wrapFn() {
    activeFn = fn
    fn()
    activeFn = null
  }
  wrapFn()
}
```

执行顺序就是：

1. 调用`watchEffect`，并传入回调函数，该回调函数会在每次执行`dep.notify()`时被调用；
2. 至于这个回调函数如何保存，主要依靠`Dep`类，该类会有一个`subscribers`的集合，用于存储回调函数；
3. 当调用`dep.depend()`时，会保存依赖到`subscribers`中，调用`dep.notify()`，会把所有回调函数执行一遍。
4. 至于`wrapFn`的定义，属于技巧了



学会了上面的内容，可以把它与数据劫持进行融合。

```js
class Dep {
  constructor() {
    this.subscribers = new Set()
  }
  depend() {
    if(activeFn) {
      this.subscribers.add(activeFn)
    }
  }
  notify() {
    this.subscribers.forEach(sub => sub())
  }
}
const dep = new Dep()

let activeFn = null

function watchEffect(fn) {
  function wrapFn() {
    activeFn = fn
    fn()
    activeFn = null
  }
  wrapFn()
}

function observer(obj) {
  Object.keys(obj).forEach(key => {
    if(obj[key] === 'object') {
      observer(obj[key])
    }
    let internalVal = obj[key]
    Object.defineProperty(obj, key, {
      get() {
        dep.depend()
        return internalVal
      },
      set(newVal) {
        internalVal = newVal
        dep.notify()
      }
    })
  })
}

const state = {
  count: 0
}
watchEffect(() => {
  console.log(`state.count updated: ${state.count}`)	// 第一次执行，就在getter里面加入了依赖
})
```

<img src="./markdown_assets/image-20250613180606035.png" alt="image-20250613180606035" style="zoom:150%;" />





























